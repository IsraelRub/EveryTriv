---
alwaysApply: true
---

# Applies to: server/\*_/_.{ts}

## ✅ Project Structure

- All source code must reside under the `src/` directory.
- Use feature-based modules: `features/`, `shared/`, `config/`, `constants/`.
- Each feature module should be self-contained with its own controllers, services, and DTOs.

## 🔧 TypeScript

- Always use TypeScript with `"strict": true` mode.
- Do not use `any`; prefer `unknown` with proper type refinement.
- Type all function inputs and outputs explicitly.
- Store shared types in `shared/types/`.
- Use TypeORM decorators for entity definitions.

## 🌐 API Design

- Use NestJS decorators for route definitions (`@Controller`, `@Get`, etc.).
- Keep business logic in services, not controllers.
- Use DTOs for request/response validation.
- Follow RESTful principles.
- Use OpenAPI/Swagger decorators for API documentation.

## 📦 Required Packages

Core:
- @nestjs/common
- @nestjs/core
- @nestjs/platform-express
- @nestjs/typeorm
- @nestjs/config
- typeorm
- class-validator
- class-transformer
- winston (for logging)

Optional:
- @nestjs/swagger
- @nestjs/caching
- @nestjs/schedule
- @nestjs/websockets

## 🧪 Testing

- Use Jest with `@nestjs/testing` for unit tests.
- Test services and controllers independently.
- Use e2e tests for full feature testing.
- Mock dependencies using NestJS's dependency injection.

## 📁 Module Structure

Each feature module should contain:
- `controllers/` – Route handlers and request/response logic
- `services/` – Business logic
- `dtos/` – Data transfer objects for validation
- `entities/` – TypeORM entities
- `types/` – Feature-specific types and interfaces
- `{feature}.module.ts` – Module definition

Shared code:
- `shared/services/` – Common services (logging, caching, etc.)
- `shared/utils/` – Utility functions
- `shared/types/` – Global types
- `shared/middleware/` – Global middleware
- `shared/modules/` – Reusable modules

## 🚀 Scripts

- `"start:dev"` – Run in development mode with hot reload
- `"build"` – Compile TypeScript
- `"start:prod"` – Run compiled code in production
- `"test"` – Run unit tests
- `"test:e2e"` – Run end-to-end tests

## 🔐 Security

- Use environment variables for sensitive data
- Implement proper authentication/authorization
- Validate all inputs using class-validator
- Use proper CORS configuration
- Implement rate limiting
- Use Helmet for security headers

## 🌟 Best Practices

- Follow Single Responsibility Principle
- Use dependency injection
- Keep controllers thin, services thick
- Use custom decorators for common functionality
- Implement proper error handling
- Use logging service instead of console.log
- Cache expensive operations
- Use TypeORM repositories for database operations

## 🎨 Code Style

- Use PascalCase for classes and interfaces
- Use camelCase for variables and functions
- Use UPPER_CASE for constants
- Use kebab-case for file names
- Add JSDoc comments for public APIs
- Follow NestJS naming conventions

## 🔄 State Management

- Use TypeORM repositories for database state
- Use Redis for caching and session storage
- Implement proper transaction handling
- Use event emitters for cross-module communication

## 📝 Documentation

- Use JSDoc comments for all public methods
- Document environment variables
- Keep README.md up to date
- Use OpenAPI/Swagger for API documentation
- Document database schema changes