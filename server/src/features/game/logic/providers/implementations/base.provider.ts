/**
 * Base Trivia Provider
 *
 * @module BaseTriviaProvider
 * @description Abstract base class for all trivia question providers
 * @used_by server/src/features/game/logic/providers
 */
import { AI_PROVIDER_ERROR_TYPES, DIFFICULTY_MULTIPLIERS, DifficultyLevel, ERROR_CONTEXT_MESSAGES, FALLBACK_QUESTION_ANSWERS, HTTP_TIMEOUTS, PROVIDER_ERROR_MESSAGES } from '@shared/constants';
import { serverLogger as logger } from '@shared/services';
import type {
	AnalyticsMetadata,
	LLMApiResponse,
	LLMResponse,
	LLMTriviaResponse,
	ProviderConfig,
	QuestionCacheMap,
	TriviaQuestion,
} from '@shared/types';
import { createAuthError } from '@internal/utils';
import { clamp, getErrorMessage, isCustomDifficulty, shuffle } from '@shared/utils';

import { PromptTemplates } from '../prompts';

/**
 * Abstract base class for trivia question providers
 * Provides common functionality for all AI providers
 */
export abstract class BaseTriviaProvider {
	protected abstract apiKey: string;
	public abstract name: string;

	// Helper method to extract metadata from trivia question
	protected extractMetadata(triviaQuestion: TriviaQuestion): Record<string, unknown> {
		return {
			actualDifficulty: triviaQuestion.difficulty,
			questionCount: 1,
			customDifficultyMultiplier: 1,
			mappedDifficulty: triviaQuestion.difficulty,
		};
	}

	protected questionCache: QuestionCacheMap = {};
	protected analytics: Partial<AnalyticsMetadata> = {};

	// Provider instance for AIProviderWithTrivia interface
	abstract provider: {
		name: string;
		config: {
			providerName: string;
			model: string;
			version: string;
			capabilities: string[];
			rateLimit: {
				requestsPerMinute: number;
				tokensPerMinute: number;
			};
			costPerToken: number;
			maxTokens: number;
			supportedLanguages: string[];
			lastUpdated: Date;
		};
		isAvailable: boolean;
		lastCheck: Date;
		errorCount: number;
		successCount: number;
		averageResponseTime: number;
		currentLoad: number;
	};

	// Updated abstract method - questionCount is not needed since it's in the prompt
	protected abstract getProviderConfig(prompt: string): ProviderConfig;

	// API call method with timeout and performance optimization
	protected async makeApiCall(_prompt: string): Promise<LLMApiResponse> {
		if (!this.apiKey) {
			throw createAuthError(PROVIDER_ERROR_MESSAGES.API_KEY_NOT_CONFIGURED);
		}

		const timeout = HTTP_TIMEOUTS.QUESTION_GENERATION; // 30 seconds timeout

		// Create a promise that rejects after timeout
		const timeoutPromise = new Promise<never>((_, reject) => {
			setTimeout(() => reject(new Error(`${this.name} API call timed out after ${timeout}ms`)), timeout);
		});

		// For now, just reject with timeout since HTTP client is not available
		return timeoutPromise;
	}

	// Implement the required generateQuestion method from LLMProvider interface
	async generateQuestion(topic: string, difficulty: string, _language: string = 'en'): Promise<LLMTriviaResponse> {
		const question = await this.generateTriviaQuestionInternal(topic, difficulty, 5);
		return {
			questions: [question],
			explanation: 'Generated by AI provider',
			content: 'Generated by AI provider',
			status: 'success' as const,
		};
	}

	// Implement the required generateTriviaQuestion method from LLMProvider interface
	async generateTriviaQuestion(topic: string, difficulty: string): Promise<TriviaQuestion> {
		return this.generateTriviaQuestionInternal(topic, difficulty, 5);
	}

	// Implement the required hasApiKey method from LLMProvider interface
	hasApiKey(): boolean {
		return Boolean(this.apiKey && this.apiKey.length > 0);
	}

	async generateTriviaQuestionInternal(
		topic: string,
		difficulty: string,
		questionCount: number = 5
	): Promise<TriviaQuestion> {
		const startTime = Date.now();

		try {
			// Use user's requested question count without optimization
			const actualQuestionCount = clamp(questionCount, 3, 5);
			const prompt = this.buildPrompt(topic, difficulty, actualQuestionCount);

			// Determine if this is a custom difficulty

			// Add performance logging
			const promptBuildTime = Date.now() - startTime;
			logger.providerStats(this.name, {
				topic,
				difficulty,
				promptBuildTime,
				questionCount: actualQuestionCount,
			});

			const response = await this.makeApiCall(prompt);

			// Parse the LLM response with smart error handling
			let data: LLMTriviaResponse;
			try {
				data = this.parseResponse(response);
			} catch (err) {
				logger.providerError(this.name, ERROR_CONTEXT_MESSAGES.INVALID_RESPONSE, {
					error: getErrorMessage(err),
					topic,
					difficulty,
				});

				// Return a fallback response with error information
				return this.createFallbackQuestion(topic, difficulty, 'PARSE_ERROR');
			}

			// Check if AI returned null response (could not generate question)
			if (!data.questions || data.questions.length === 0) {
				logger.providerError(this.name, 'AI could not generate question', {
					topic,
					difficulty,
					explanation: data.explanation || 'No explanation provided',
				});

				return this.createFallbackQuestion(topic, difficulty, 'VALIDATION_ERROR');
			}

			// Calculate custom difficulty multiplier if needed

			// Create trivia question object
			const firstQuestion = data.questions[0];
			const question: TriviaQuestion = {
				id: `question_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
				topic: topic,
				difficulty: difficulty,
				question: firstQuestion.question,
				answers: firstQuestion.answers.map((answer, i: number) => ({
					text: answer.text,
					isCorrect: i === firstQuestion.correctAnswerIndex,
				})),
				correctAnswerIndex: firstQuestion.correctAnswerIndex,
				createdAt: new Date(),
				updatedAt: new Date(),
			};

			// Validate the question quality
			if (!question.question || !question.answers || question.answers.length < 2) {
				logger.providerError(this.name, 'Question validation failed: Invalid question format', {
					topic,
					difficulty,
					errors: ['Invalid question format'],
				});

				// Return fallback question instead of invalid one
				return this.createFallbackQuestion(topic, difficulty, 'VALIDATION_ERROR');
			}

			// Sanitize the question
			question.question = question.question.trim();
			question.answers = question.answers.map(answer => ({
				...answer,
				text: answer.text.trim(),
			}));

			// Shuffle answers to prevent position bias
			question.answers = this.shuffleArray(question.answers);
			logger.providerSuccess(this.name, {
				topic,
				difficulty,
			});

			// Check for duplicates and cache the question
			if (this.isDuplicate(question)) {
				logger.providerFallback(this.name, {
					topic,
					difficulty,
				});
				// In a real implementation, you might want to retry with a different prompt
			}

			// Add question to cache
			this.addQuestion(question);
			logger.providerSuccess(this.name, {
				topic,
				difficulty,
			});

			// Record analytics
			const responseTime = Date.now() - startTime;
			this.recordQuestion(question, responseTime);
			logger.providerStats(this.name, {
				topic,
				difficulty,
				responseTime,
			});

			return question;
		} catch (error) {
			this.recordError();
			logger.providerError(this.name, ERROR_CONTEXT_MESSAGES.AI_GENERATION_FAILED, {
				error: getErrorMessage(error),
				topic,
				difficulty,
			});

			// Return fallback question instead of throwing error
			return this.createFallbackQuestion(topic, difficulty, 'API_ERROR');
		}
	}

	protected buildPrompt(topic: string, difficulty: string, questionCount: number): string {
		// Use the advanced prompt generation with full quality guidelines
		return PromptTemplates.generateTriviaQuestion({
			topic,
			difficulty,
			questionCount: questionCount,
			isCustomDifficulty: isCustomDifficulty(difficulty),
		});
	}

	protected abstract parseResponse(response: LLMResponse): LLMTriviaResponse;

	protected getDifficultyMultiplier(difficulty: DifficultyLevel): number {
		switch (difficulty) {
			case DifficultyLevel.EASY:
				return DIFFICULTY_MULTIPLIERS[DifficultyLevel.EASY];
			case DifficultyLevel.MEDIUM:
				return DIFFICULTY_MULTIPLIERS[DifficultyLevel.MEDIUM];
			case DifficultyLevel.HARD:
				return DIFFICULTY_MULTIPLIERS[DifficultyLevel.HARD];
			default:
				return DIFFICULTY_MULTIPLIERS.CUSTOM_DEFAULT;
		}
	}

	// Helper methods for caching and analytics
	protected isDuplicate(question: TriviaQuestion): boolean {
		const key = `${question.question.toLowerCase().trim()}`;
		return this.questionCache[key] !== undefined;
	}

	protected addQuestion(question: TriviaQuestion): void {
		const key = `${question.question.toLowerCase().trim()}`;
		this.questionCache[key] = {
			question: {
				question: question.question,
				answers: question.answers.map(a => a.text),
				correctAnswerIndex: question.correctAnswerIndex,
				difficulty: question.difficulty,
				topic: question.topic,
			},
			created_at: question.createdAt,
			accessCount: 0,
			lastAccessed: new Date(),
		};
	}

	protected recordQuestion(question: TriviaQuestion, responseTime: number): void {
		if (!this.analytics.questions) {
			this.analytics.questions = [];
		}
		this.analytics.questions.push({
			id: `analytics_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
			topic: question.topic || 'unknown',
			difficulty: question.difficulty || 'unknown',
			responseTime,
			timestamp: new Date(),
		});
	}

	protected recordError(): void {
		if (!this.analytics.errors) {
			this.analytics.errors = [];
		}
		this.analytics.errors.push({
			timestamp: new Date(),
			provider: this.name,
		});
	}

	protected shuffleArray<T>(array: T[]): T[] {
		return shuffle(array);
	}

	/**
	 * Create a fallback question when AI generation fails
	 */
	protected createFallbackQuestion(
		topic: string,
		difficulty: string,
		errorType: keyof typeof AI_PROVIDER_ERROR_TYPES
	): TriviaQuestion {
		return {
			id: `fallback_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
			topic: topic,
			difficulty: difficulty,
			question: AI_PROVIDER_ERROR_TYPES[errorType],
			answers: FALLBACK_QUESTION_ANSWERS.map(answer => ({
				text: answer.text,
				isCorrect: answer.isCorrect,
			})),
			correctAnswerIndex: 0,
			createdAt: new Date(),
			updatedAt: new Date(),
		};
	}
}
