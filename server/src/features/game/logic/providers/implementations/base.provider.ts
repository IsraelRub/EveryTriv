/**
 * Base Trivia Provider
 *
 * @module BaseTriviaProvider
 * @description Abstract base class for all trivia question providers
 * @used_by server/src/features/game/logic/providers
 */
import { DIFFICULTY_MULTIPLIERS, DifficultyLevel } from '@shared/constants/game.constants';
import { LoggerService } from '@shared/controllers';
import {
	AI_PROVIDER_ERROR_TYPES,
	ERROR_CONTEXT_MESSAGES,
	FALLBACK_QUESTION_ANSWERS,
	FALLBACK_QUESTION_METADATA,
	// ERROR_LOGGING_CONTEXT,
	PROVIDER_ERROR_MESSAGES,
} from 'everytriv-shared/constants/error.constants';
import {
	AnalyticsMetadata,
	ApiRequestBody,
	GenericDataValue,
	LLMApiResponse,
	LLMProvider,
	LLMTriviaResponse,
	ProviderConfig,
	QuestionCacheMap,
	TriviaQuestion,
} from 'everytriv-shared/types';
import {
	clamp,
	extractCustomDifficultyText,
	generateId,
	generateQuestionId,
	isCustomDifficulty,
	shuffle,
} from 'everytriv-shared/utils';

import { PromptTemplates } from '../prompts';

/**
 * Abstract base class for trivia question providers
 * Provides common functionality for all AI providers
 */
export abstract class BaseTriviaProvider<TResponse = GenericDataValue> implements LLMProvider {
	protected abstract apiKey: string;
	public abstract name: string;

	constructor() {
		// Initialize provider-specific configuration
	}

	// Helper method to extract metadata from trivia question
	protected extractMetadata(triviaQuestion: TriviaQuestion): Record<string, unknown> {
		return {
			actualDifficulty: triviaQuestion.metadata?.actualDifficulty,
			questionCount: triviaQuestion.metadata?.questionCount,
			customDifficultyMultiplier: triviaQuestion.metadata?.customDifficultyMultiplier,
			mappedDifficulty: triviaQuestion.metadata?.mappedDifficulty,
		};
	}

	protected questionCache: QuestionCacheMap = {};
	protected analytics: AnalyticsMetadata = {};
	protected logger: LoggerService = new LoggerService();

	// Provider instance for AIProviderWithTrivia interface
	abstract provider: {
		name: string;
		config: {
			providerName: string;
			model: string;
			version: string;
			capabilities: string[];
			rateLimit: {
				requestsPerMinute: number;
				tokensPerMinute: number;
			};
			costPerToken: number;
			maxTokens: number;
			supportedLanguages: string[];
			lastUpdated: Date;
		};
		isAvailable: boolean;
		lastCheck: Date;
		errorCount: number;
		successCount: number;
		averageResponseTime: number;
		currentLoad: number;
	};

	// Updated abstract method - questionCount is not needed since it's in the prompt
	protected abstract getProviderConfig(prompt: string): ProviderConfig;

	// Unified API call method with timeout and performance optimization
	protected async makeApiCall(prompt: string): Promise<LLMApiResponse> {
		if (!this.apiKey) {
			throw new Error(PROVIDER_ERROR_MESSAGES.API_KEY_NOT_CONFIGURED);
		}

		const config = this.getProviderConfig(prompt);
		const timeout = 30000; // 30 seconds timeout

		// Import server HTTP client
		const { serverHttpClient } = await import('../../../../../shared/modules/http');

		// Create a promise that rejects after timeout
		const timeoutPromise = new Promise<never>((_, reject) => {
			setTimeout(() => reject(new Error(`${this.name} API call timed out after ${timeout}ms`)), timeout);
		});

		// Race between the API call and timeout
		return Promise.race([
			serverHttpClient.post(config.url, config.body as ApiRequestBody) as Promise<LLMApiResponse>,
			timeoutPromise,
		]);
	}

	// Implement the required generateQuestion method from LLMProvider interface
	async generateQuestion(topic: string, difficulty: string, _language: string = 'en'): Promise<LLMTriviaResponse> {
		const question = await this.generateTriviaQuestionInternal(topic, difficulty, 5);
		return {
			question: question.question,
			answers: question.answers.map(a => a.text),
			mappedDifficulty: question.metadata?.mappedDifficulty,
			explanation: 'Generated by AI provider',
		};
	}

	// Implement the required generateTriviaQuestion method from LLMProvider interface
	async generateTriviaQuestion(topic: string, difficulty: string): Promise<TriviaQuestion> {
		return this.generateTriviaQuestionInternal(topic, difficulty, 5);
	}

	// Implement the required hasApiKey method from LLMProvider interface
	hasApiKey(): boolean {
		return Boolean(this.apiKey && this.apiKey.length > 0);
	}

	async generateTriviaQuestionInternal(
		topic: string,
		difficulty: string,
		questionCount: number = 5
	): Promise<TriviaQuestion> {
		const startTime = Date.now();

		try {
			// Use user's requested question count without optimization
			const actualQuestionCount = clamp(questionCount, 3, 5);
			const prompt = this.buildPrompt(topic, difficulty, actualQuestionCount);

			// Determine if this is a custom difficulty
			const actualDifficulty = isCustomDifficulty(difficulty) ? extractCustomDifficultyText(difficulty) : difficulty;

			// Add performance logging
			const promptBuildTime = Date.now() - startTime;
			this.logger.providerStats(this.name, {
				topic,
				difficulty,
				promptBuildTime,
				questionCount: actualQuestionCount,
			});

			const response = await this.makeApiCall(prompt);

			// Parse the LLM response with smart error handling
			let data: LLMTriviaResponse;
			try {
				data = this.parseResponse(response as LLMApiResponse<TResponse>);
			} catch (err) {
				this.logger.providerError(this.name, ERROR_CONTEXT_MESSAGES.INVALID_RESPONSE, {
					error: err instanceof Error ? err.message : 'Unknown error',
					topic,
					difficulty,
				});

				// Return a fallback response with error information
				return this.createFallbackQuestion(
					topic,
					difficulty,
					'PARSE_ERROR',
					err instanceof Error ? err.message : 'Unknown parsing error'
				);
			}

			// Check if AI returned null response (could not generate question)
			if (data.question === null || !data.answers || data.answers.length === 0) {
				this.logger.providerError(this.name, 'AI could not generate question', {
					topic,
					difficulty,
					explanation: data.explanation || 'No explanation provided',
				});

				return this.createFallbackQuestion(
					topic,
					difficulty,
					'VALIDATION_ERROR',
					data.explanation || ERROR_CONTEXT_MESSAGES.QUESTION_GENERATION_FAILED
				);
			}

			// Calculate custom difficulty multiplier if needed
			const customDifficultyMultiplier = isCustomDifficulty(difficulty)
				? this.getDifficultyMultiplier(data.mappedDifficulty as DifficultyLevel)
				: undefined;

			// Create trivia question object
			const question: TriviaQuestion = {
				id: generateQuestionId(),
				topic: topic,
				difficulty: difficulty,
				question: data.question,
				answers: data.answers.map((text: string, i: number) => ({
					text,
					isCorrect: i === 0,
				})),
				correct_answer_index: 0,
				created_at: new Date(),
				metadata: {
					actualDifficulty: isCustomDifficulty(difficulty) ? actualDifficulty : difficulty,
					questionCount: actualQuestionCount,
					customDifficultyMultiplier: isCustomDifficulty(difficulty) ? customDifficultyMultiplier : undefined,
					mappedDifficulty: isCustomDifficulty(difficulty) ? (data.mappedDifficulty as DifficultyLevel) : undefined,
				},
			};

			// Validate the question quality
			if (!question.question || !question.answers || question.answers.length < 2) {
				this.logger.providerError(this.name, 'Question validation failed: Invalid question format', {
					topic,
					difficulty,
					errors: ['Invalid question format'],
				});

				// Return fallback question instead of invalid one
				return this.createFallbackQuestion(
					topic,
					difficulty,
					'VALIDATION_ERROR',
					ERROR_CONTEXT_MESSAGES.INVALID_RESPONSE
				);
			}

			// Sanitize the question
			question.question = question.question.trim();
			question.answers = question.answers.map(answer => ({
				...answer,
				text: answer.text.trim(),
			}));

			// Shuffle answers to prevent position bias
			question.answers = this.shuffleArray(question.answers);
			this.logger.providerSuccess(this.name, {
				topic,
				difficulty,
			});

			// Check for duplicates and cache the question
			if (this.isDuplicate(question)) {
				this.logger.providerFallback(this.name, {
					topic,
					difficulty,
				});
				// In a real implementation, you might want to retry with a different prompt
			}

			// Add question to cache
			this.addQuestion(question);
			this.logger.providerSuccess(this.name, {
				topic,
				difficulty,
			});

			// Record analytics
			const responseTime = Date.now() - startTime;
			this.recordQuestion(question, responseTime);
			this.logger.providerStats(this.name, {
				topic,
				difficulty,
				responseTime,
			});

			return question;
		} catch (error) {
			this.recordError();
			this.logger.providerError(this.name, ERROR_CONTEXT_MESSAGES.AI_GENERATION_FAILED, {
				error: error instanceof Error ? error.message : 'Unknown error',
				topic,
				difficulty,
			});

			// Return fallback question instead of throwing error
			return this.createFallbackQuestion(
				topic,
				difficulty,
				'API_ERROR',
				error instanceof Error ? error.message : ERROR_CONTEXT_MESSAGES.AI_GENERATION_FAILED
			);
		}
	}

	protected buildPrompt(topic: string, difficulty: string, questionCount: number): string {
		// Use the advanced prompt generation with full quality guidelines
		return PromptTemplates.generateTriviaQuestion({
			topic,
			difficulty,
			answerCount: questionCount,
			isCustomDifficulty: isCustomDifficulty(difficulty),
		});
	}

	protected abstract parseResponse(response: LLMApiResponse<TResponse>): LLMTriviaResponse;

	protected getDifficultyMultiplier(difficulty: DifficultyLevel): number {
		switch (difficulty) {
			case DifficultyLevel.EASY:
				return DIFFICULTY_MULTIPLIERS[DifficultyLevel.EASY];
			case DifficultyLevel.MEDIUM:
				return DIFFICULTY_MULTIPLIERS[DifficultyLevel.MEDIUM];
			case DifficultyLevel.HARD:
				return DIFFICULTY_MULTIPLIERS[DifficultyLevel.HARD];
			default:
				return DIFFICULTY_MULTIPLIERS.CUSTOM_DEFAULT;
		}
	}

	// Helper methods for caching and analytics
	protected isDuplicate(question: TriviaQuestion): boolean {
		const key = `${question.question.toLowerCase().trim()}`;
		return this.questionCache[key] !== undefined;
	}

	protected addQuestion(question: TriviaQuestion): void {
		const key = `${question.question.toLowerCase().trim()}`;
		this.questionCache[key] = {
			question: {
				id: question.id,
				question: question.question,
				answers: question.answers.map(a => a.text),
				correctAnswerIndex: question.correct_answer_index,
				difficulty: question.difficulty,
				topic: question.topic,
			},
			created_at: question.created_at,
			accessCount: 0,
			lastAccessed: new Date(),
		};
	}

	protected recordQuestion(question: TriviaQuestion, responseTime: number): void {
		if (!this.analytics.questions) {
			this.analytics.questions = [];
		}
		this.analytics.questions.push({
			id: question.id,
			topic: question.metadata?.actualDifficulty || 'unknown',
			difficulty: question.metadata?.actualDifficulty || 'unknown',
			responseTime,
			timestamp: new Date(),
		});
	}

	protected recordError(): void {
		if (!this.analytics.errors) {
			this.analytics.errors = [];
		}
		this.analytics.errors.push({
			timestamp: new Date(),
			provider: this.name,
		});
	}

	protected shuffleArray<T>(array: T[]): T[] {
		return shuffle(array);
	}

	/**
	 * Create a fallback question when AI generation fails
	 */
	protected createFallbackQuestion(
		topic: string,
		difficulty: string,
		errorType: keyof typeof AI_PROVIDER_ERROR_TYPES,
		errorMessage: string
	): TriviaQuestion {
		return {
			id: `fallback_${Date.now()}_${generateId(9)}`,
			topic: topic,
			difficulty: difficulty,
			question: AI_PROVIDER_ERROR_TYPES[errorType],
			answers: [...FALLBACK_QUESTION_ANSWERS],
			correct_answer_index: 0,
			created_at: new Date(),
			metadata: {
				actualDifficulty: difficulty,
				questionCount: FALLBACK_QUESTION_METADATA.QUESTION_COUNT,
				isFallback: FALLBACK_QUESTION_METADATA.IS_FALLBACK,
				errorType: errorType,
				errorMessage,
				fallbackReason: AI_PROVIDER_ERROR_TYPES[errorType],
			},
		};
	}
}
